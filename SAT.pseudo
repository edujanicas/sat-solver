clause.c
	bool CLAUSEnew(V<Var> literals, bool learnt, clause* output) {
		if(! learnt) {
			if(CLAUSEclean) {
				return true;
			}
			
			if("contains p and -p") return true

			for(p : literals) {
				"remove duplicates of p"
			}
		}

		// special cases : length == 0,1
		if(literals->size() == 0)
			return false
		if(literals->size() == 1)
			//enqueue keeps track of propagations to do
			sat.c :: enqueue(literals->get(0)->id) 
		else { // normal case : length >= 2

			"instantiate output"

			"set clause activity to 0" //will need the clause data type after all

			if(learnt) {
				"if learnt set the second watched literal (the first one is random) to
					be the literal with the highest decision level"
					//will also need the cause data type for remembering wathced lits
					//maybe, minisat remembers it as "literals in position 0 and 1"
				sat.c :: bumpActivity("this clause") 
				for (p : literals)	
					sat.c :: bumpActivityVar(p)
			}

			//new field in the sat : watchers
			"add the clause to the watcher list of its watched literals"
		}
	}

	//returns true if the clause evaluate trivially to true
	//otherwise remove all false lits and return false
	bool CLAUSEclean(clause* clause) {
		if("any literal is true") return true
		for(p : literals) {
			"remove p if p->value == false"
		}
		return false
	}

	//return false if the clause is unit and the unit variable is already 
	//present in the propagation queue with opposit sign
	bool CLAUSEpropagate(clause* clause, Var p) {
		//if this method has been called, this clause was watching p
		//so -p is either in position 0 or 1
		"make sure neg(p) is in position 1"

		if("clause[0] is true")
			//then the clause is already satisfied
			"re insert clause into watchers[p]"
			return true;

		for (Var q : "vars from index 2 on") {
			if ("q is not false-assigned") {
				"swap -p and q"
				"add clause to wathcers of -q"
				return true;
			}

		}

		//if no watchable literals is found (should have returned by now)
		//clause is unit under current assignment
		//(and the only unassigned literal may be the zero-th)
		"re insert clause into watchers[p]"

		//as wee can then infer that literal, add it into propagation queue
		return sat :: enqueue(clause->vars[0]) //returns false on conflicts


	}

sat.c
	//enqueues vars for future propagation
	//return false on conflicts, true otherwise
	bool enqueue(Var p) {
		//if it has already been assigned
		if(assigned(p)) {
			if(value(p) == false)
				"conflict"
			if(value(p) == true) //already propagated
				return true
		} else {
			assignments[p->value()] = p->sign()
		}
	}

	bool value(Var p){
		if(p->sign() == true) {
			return assignments[p->id()]
		} else if((p->sign() == false))
			return !assignments[p->id()]
	}

	//return the conflicting clause on conflict
	//NULL otherwise
	clause propagate() {
		while (propagationQ->size() > 0) {
			Var propagatingVar = propagationQ->dequeue()

			watchers[p]->remove("the clauses watching p")
			V propagationWatchers = "the clauses watching p"

			for(clause* clause : propagationWatchers) {
				if(!CLAUSEpropagate(clause, propagatingVar)) {
					//clause was unit and conflicting
					watchers[p]->add("the clauses watching p, from the one 
										after the conflicting one on")
					propagationQ->flush()
					return clause;
				}
			}
		}
		return NULL;
	}

	/*
		Starting with the conflict clause and null p, expand the reasoning 
		that led to a conflict for all variables of this level but one.
		(But one b/c it has been proven heuristically valid)

		The next clauses are the reasons for the last lits on the trail

		You expand lits by getting the negation of all the conflict clause at first, and for every other clause negation of all the lits
		but the first (its the one that led to the clause being unit)

		Then every time you encounter a literal in the clauses negations,
		if its not from level 0 or from the last one, you add it to the
		clause to be learnt (start from 1, out[0] will be the last lit 
		took from the trail)

		the backtrack level is the max level in which added vars were
		decided
		
		For some reason (?) it will not undo past current decision level
	*/
	int analyze(C conflictClause, @Output Array<Var> learntClauseLits) {
		p = "null_literal"
		backtrackLevel = 0;
		count = 0;
		seen[]

		do {

			VECTORclear(reason_p)
			if(conflictClause != NULL) {

				//returns the negation of all literals in conflictClause
				//minus the first if p != NULL as the first one is p
				reason_p = CLAUSEreasonFor(conflictClause, p);
				
				for (Var q : reason_p) {
					if (! encountered[p->id]) {
						encountered[p->id] = true;
						if ("q has this decision level")
							count ++ 

						if ("0 < q decision level < current decision level") {
							"add q to learntClauseLits"
							backtrackLevel = max(backtrackLevel, "q decision level")
						}
					}
				}
			}
			//select next literal and conflict clause(first unseen literal in trail)
			do {
				p = "last item in trail"
				confl = reason[p->id]

				//how do we know we won't undo the trail past this level?
				undoOne();
			} while (!seen[p->id])
			count --;

		} while (count > 0);

		return backtrackLevel;
	}

var.c
	Var neg(Var p) {
		return -p;
	}