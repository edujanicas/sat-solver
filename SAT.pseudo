clause.c
	bool CLAUSEnew(V<Var> literals, bool learnt, clause* output) {
		if(! learnt) {
			if(CLAUSEclean) {
				return true;
			}
			
			if("contains p and -p") return true

			for(p : literals) {
				"remove duplicates of p"
			}
		}

		// special cases : length == 0,1
		if(literals->size() == 0)
			return false
		if(literals->size() == 1)
			//enqueue keeps track of propagations to do
			sat.c :: enqueue(literals->get(0)->id) 
		else { // normal case : length >= 2

			"instantiate output"

			"set clause activity to 0" //will need the clause data type after all

			if(learnt) {
				"if learnt set the second watched literal (the first one is random) to
					be the literal with the highest decision level"
					//will also need the cause data type for remembering wathced lits
					//maybe, minisat remembers it as "literals in position 0 and 1"
				sat.c :: bumpActivity("this clause") 
				for (p : literals)	
					sat.c :: bumpActivityVar(p)
			}

			//new field in the sat : watchers
			"add the clause to the watcher list of its watched literals"
		}
	}

	//returns true if the clause evaluate trivially to true
	//otherwise remove all false lits and return false
	bool CLAUSEclean(clause* clause) {
		if("any literal is true") return true
		for(p : literals) {
			"remove p if p->value == false"
		}
		return false
	}

	//return false if the clause is unit and the unit variable is already 
	//present in the propagation queue with opposit sign
	bool CLAUSEpropagate(clause* clause, Var p) {
		//if this method has been called, this clause was watching p
		//so -p is either in position 0 or 1
		"make sure neg(p) is in position 1"

		if("clause[0] is true")
			//then the clause is already satisfied
			"re insert clause into watchers[p]"
			return true;

		for (Var q : "vars from index 2 on") {
			if ("q is not false-assigned") {
				"swap -p and q"
				"add clause to wathcers of -q"
				return true;
			}

		}

		//if no watchable literals is found (should have returned by now)
		//clause is unit under current assignment
		//(and the only unassigned literal may be the zero-th)
		"re insert clause into watchers[p]"

		//as wee can then infer that literal, add it into propagation queue
		return sat :: enqueue(clause->vars[0]) //returns false on conflicts


	}

sat.c
	//enqueues vars for future propagation
	//return false on conflicts, true otherwise
	bool enqueue(Var p) {
		//if it has already been assigned
		if(assigned(p)) {
			if(value(p) == false)
				"conflict"
			if(value(p) == true) //already propagated
				return true
		} else {
			//I dont understand why negated signe [Mario]
			assignments[p->value()] = !p->sign()
		}

		//TODO
	}

	bool value(Var p){
		if(p->sign() == true) {
			return assignments[p->id()]
		} else if((p->sign() == false))
			return !assignments[p->id()]
	}

	//return the conflicting clause on conflict
	//NULL otherwise
	clause propagate() {
		while (propagationQ->size() > 0) {
			Var propagatingVar = propagationQ->dequeue()

			watchers[p]->remove("the clauses watching p")
			V propagationWatchers = "the clauses watching p"

			for(clause* clause : propagationWatchers) {
				if(!CLAUSEpropagate(clause, propagatingVar)) {
					//clause was unit and conflicting
					watchers[p]->add("the clauses watching p, from the one 
										after the conflicting one on")
					propagationQ->flush()
					return clause;
				}
			}
		}
		return NULL;
	}

var.c
	Var neg(Var p) {
		return -p;
	}